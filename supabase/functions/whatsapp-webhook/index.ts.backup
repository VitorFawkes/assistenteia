import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from 'jsr:@supabase/supabase-js@2';

const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const evolutionApiUrl = Deno.env.get('EVOLUTION_API_URL')!;
const evolutionApiKey = Deno.env.get('EVOLUTION_API_KEY')!;

const supabase = createClient(supabaseUrl, supabaseKey);

Deno.serve(async (req: Request) => {
    try {
        const body = await req.json();
        const { instance, data, event } = body;

        // 0. HANDLE CONNECTION UPDATES
        if (event === 'CONNECTION_UPDATE') {
            const { state } = data;
            console.log(`üîå Connection Update for ${instance}: ${state}`);

            let newStatus = 'disconnected';
            if (state === 'open') newStatus = 'connected';
            else if (state === 'connecting') newStatus = 'connecting';

            await supabase
                .from('whatsapp_instances')
                .update({
                    status: newStatus,
                    updated_at: new Date().toISOString()
                })
                .eq('instance_name', instance);

            return new Response(JSON.stringify({ success: true, status: newStatus }), { headers: { 'Content-Type': 'application/json' } });
        }

        // 1. FILTER: Only process messages.upsert
        if (event !== 'messages.upsert') {
            return new Response(JSON.stringify({ ignored: true }), { headers: { 'Content-Type': 'application/json' } });
        }

        const message = data;
        if (!message || !message.key) {
            return new Response(JSON.stringify({ error: 'No message data' }), { headers: { 'Content-Type': 'application/json' } });
        }

        // LOG INCOMING
        await supabase.from('debug_logs').insert({
            function_name: 'whatsapp-webhook',
            level: 'info',
            message: 'Webhook received',
            meta: { event, instance, key: message.key }
        });

        // 2. IDENTIFY USER BY PHONE NUMBER
        const { remoteJid, fromMe } = message.key;

        // Extract phone number from JID (remove @s.whatsapp.net)
        // Format: 5511999999999
        const senderPhone = remoteJid.split('@')[0];
        const formattedPhone = '+' + senderPhone; // Add + to match DB format if needed, or adjust DB to store without +

        console.log(`üîç Looking up user for phone: ${formattedPhone}`);

        // Find user who owns this phone number
        const { data: userData, error: userError } = await supabase
            .from('user_settings')
            .select('user_id, bot_mode')
            .or(`phone_number.eq.${formattedPhone},phone_number.eq.${senderPhone}`) // Try both formats
            .maybeSingle();

        if (!userData || userError) {
            console.log(`‚ùå User not found for phone ${formattedPhone}. Ignoring.`);
            return new Response(JSON.stringify({ ignored: 'user_not_found' }), { headers: { 'Content-Type': 'application/json' } });
        }

        console.log(`‚úÖ User identified: ${userData.user_id} (Mode: ${userData.bot_mode})`);

        // 3. CHECK BOT MODE (PASSIVE VS ACTIVE)
        // If mode is 'mention_only', we only process if:
        // - It's a direct message (remoteJid does not contain 'g.us' for groups? No, remoteJid is the chat ID).
        // - Actually, for 1:1 chats, remoteJid is the user's number. For groups, it's groupID.
        // - Wait, if it's a group, message.key.participant has the sender.

        // Let's refine:
        // If it's a GROUP message (remoteJid ends in @g.us):
        //   - We need to check if Bot was mentioned OR if it's 'always_reply' (maybe not for groups?).
        //   - For now, let's assume 1:1 chat primarily.

        // PASSIVE MODE LOGIC for 1:1:
        // If bot_mode is 'mention_only', we only reply if message starts with "Bot" or similar?
        // User said: "agir no que eu pedir e quando eu pedir".
        // Let's implement a simple keyword check for now if in passive mode.

        let shouldProcess = true;
        if (userData.bot_mode === 'mention_only') {
            // Check if message content triggers the bot
            const msgText = (message.message?.conversation || message.message?.extendedTextMessage?.text || '').toLowerCase();
            const triggers = ['bot', 'assistente', 'ajuda', 'help'];
            const isTriggered = triggers.some(t => msgText.startsWith(t));

            if (!isTriggered) {
                console.log('üí§ Passive Mode: Message did not trigger bot. Ignoring.');
                shouldProcess = false;
            }
        }

        if (!shouldProcess) {
            // We still might want to SAVE the message for history, but NOT reply?
            // User said "agir... quando eu pedir".
            // If we don't process, we don't generate response.
            // But maybe we should save it?
            // For now, let's just IGNORE completely to save resources as requested ("nao ter gasto absurdo").
            return new Response(JSON.stringify({ ignored: 'passive_mode' }), { headers: { 'Content-Type': 'application/json' } });
        }

        console.log('‚úÖ Processing Message');

        // 3. EXTRACT CONTENT & MEDIA
        const msgContent = message.message;
        if (!msgContent) return new Response(JSON.stringify({ ignored: 'no_content' }));

        let content = '';
        let mediaType = null;
        let mediaBase64 = null;

        // Text
        content = msgContent.conversation || msgContent.extendedTextMessage?.text || '';

        // Audio
        if (msgContent.audioMessage) {
            mediaType = 'audio';
            console.log('üé§ Audio message detected');

            // Strategy: Check payload -> Fallback to Fetch
            if (message.base64) {
                mediaBase64 = message.base64;
                console.log('‚úÖ Base64 found in payload');
            } else {
                console.log('‚ö†Ô∏è Base64 MISSING in payload. Fetching from Evolution...');

                // Call Evolution to get Base64
                // Endpoint: /chat/getBase64FromMediaMessage/{instance}
                // Body: { message: { ... } }
                try {
                    const fetchResponse = await fetch(`${evolutionApiUrl}/chat/getBase64FromMediaMessage/${instance}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'apikey': evolutionApiKey
                        },
                        body: JSON.stringify({
                            message: message,
                            convertToMp4: false
                        })
                    });

                    if (fetchResponse.ok) {
                        const fetchData = await fetchResponse.json();
                        if (fetchData.base64) {
                            mediaBase64 = fetchData.base64;
                            console.log('‚úÖ Base64 fetched successfully from Evolution');
                        } else {
                            console.error('‚ùå Evolution returned no base64');
                        }
                    } else {
                        console.error(`‚ùå Failed to fetch base64: ${fetchResponse.status}`);
                        const errText = await fetchResponse.text();
                        console.error('Error details:', errText);
                    }
                } catch (e) {
                    console.error('‚ùå Exception fetching base64:', e);
                }
            }
        }
        // Image (Optional, but good to have)
        else if (msgContent.imageMessage) {
            mediaType = 'image';
            content = msgContent.imageMessage.caption || '';
            // Same logic for image base64 if needed, but focusing on audio for now
        }

        // 4. PREPARE PAYLOAD FOR PROCESS-MESSAGE
        let finalMediaUrl = null;
        if (mediaType === 'audio' && mediaBase64) {
            // Construct Data URI
            // Audio messages are usually ogg/opus
            finalMediaUrl = `data:audio/ogg;base64,${mediaBase64}`;
        }

        // 5. CALL PROCESS-MESSAGE
        // We already have userData.user_id from step 2.

        console.log(`üöÄ Forwarding to process-message. Content: "${content}", Media: ${mediaType}`);

        // 4.5 INSERT MESSAGE INTO DATABASE (Fix for visibility)
        // We must save the user's message so it appears in the chat history
        const { data: insertedMessage, error: insertError } = await supabase.from('messages').insert({
            user_id: userData.user_id,
            role: 'user',
            content: content || (mediaType ? `[${mediaType.toUpperCase()}]` : null),
            media_url: finalMediaUrl || null, // Prefer Data URI if available
            media_type: mediaType || null
        }).select('id').single();

        if (insertError) {
            console.error('‚ùå Error saving user message to DB:', insertError);
            // We continue even if save fails, to ensure AI still replies? 
            // Or we stop? Let's log and continue, but it's a critical failure for UI visibility.
            await supabase.from('debug_logs').insert({
                function_name: 'whatsapp-webhook',
                level: 'error',
                message: 'Failed to save user message',
                meta: { error: insertError }
            });
        } else {
            console.log('‚úÖ User message saved to DB:', insertedMessage?.id);
        }

        await supabase.from('debug_logs').insert({
            function_name: 'whatsapp-webhook',
            level: 'info',
            message: 'Forwarding to process-message',
            meta: { content, mediaType, userId: userData.user_id, messageId: insertedMessage?.id }
        });

        // Call the Edge Function
        const { data: processData, error: processError } = await supabase.functions.invoke('process-message', {
            body: {
                content: content,
                mediaUrl: finalMediaUrl,
                mediaType: mediaType,
                userId: userData.user_id,
                messageId: insertedMessage?.id
            }
        });

        if (processError) {
            console.error('‚ùå Error invoking process-message:', processError);
            throw processError;
        }

        if (processData && processData.response) {
            console.log('ü§ñ AI Response:', processData.response);

            // Send response back via Evolution API
            const sendResponse = await fetch(`${evolutionApiUrl}/message/sendText/${instance}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': evolutionApiKey
                },
                body: JSON.stringify({
                    number: remoteJid,
                    text: processData.response,
                    delay: 1200,
                    linkPreview: true
                })
            });

            if (!sendResponse.ok) {
                console.error('‚ùå Failed to send WhatsApp response:', await sendResponse.text());
            } else {
                console.log('‚úÖ Response sent to WhatsApp');
            }
        }

        return new Response(JSON.stringify({ success: true }), { headers: { 'Content-Type': 'application/json' } });

    } catch (error: any) {
        console.error('CRITICAL WEBHOOK ERROR:', error);
        await supabase.from('debug_logs').insert({
            function_name: 'whatsapp-webhook',
            level: 'error',
            message: 'Critical Error',
            meta: { error: error.message }
        });
        return new Response(JSON.stringify({ error: error.message }), { status: 500, headers: { 'Content-Type': 'application/json' } });
    }
});
