        if (!validation.valid) {
            return JSON.stringify({ success: false, error: validation.error });
        }

        const { data, error } = await supabase.from('collections').insert({
            user_id: userId,
            name: args.name,
            description: args.description || null,
            icon: args.icon || 'üìÅ',
            metadata: {
                entity_type: entityType,
                created_by: 'ai_agent',
                ...entityMetadata // Merge validated metadata
            }
        }).select().single();

        if (error) {
            return JSON.stringify({ success: false, error: `Database error: ${error.message}` });
        }

        return JSON.stringify({
            success: true,
            message: `Entidade '${args.name}' criada com sucesso.`,
            entity: {
                id: data.id,
                name: data.name,
                type: entityType,
                icon: data.icon
            }
        });

    } else if (args.action === 'list') {
        const { data } = await supabase.from('collections').select('name, metadata').eq('user_id', userId);
        const formatted = data?.map((c: any) => `${c.name} (${c.metadata?.entity_type || 'generic'})`).join(', ') || 'Nenhuma';
        return JSON.stringify({ success: true, collections: data }); // Return raw data for AI to parse if needed, or summary
    } else if (args.action === 'update') {
        // ... (Update logic needs to be JSON-ified too, but let's start with create/list for now to keep diff small)
        // Actually, let's do it all for consistency.
        const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.name).maybeSingle();
        if (!coll) {
            return JSON.stringify({ success: false, error: `Pasta "${args.name}" n√£o encontrada.` });
        }

        const updateData: any = {};
        if (args.new_name) updateData.name = args.new_name;
        if (args.description) updateData.description = args.description;
        if (args.icon) updateData.icon = args.icon;

        // Allow updating entity_type if explicitly requested (migration scenario)
        if (args.entity_type) {
            const validation = validateEntity(args.entity_type, {});
            if (!validation.valid) return JSON.stringify({ success: false, error: validation.error });
            // We need to merge with existing metadata, not overwrite blindly.
            // For now, let's assume we just update the field.
            // But supabase update on jsonb column replaces the whole object or needs special syntax?
            // Supabase/Postgres updates the whole column. We need to fetch existing metadata first?
            // Or use jsonb_set. For simplicity, let's skip metadata update in this refactor unless critical.
            // The prompt says "Every time you create or update... classify".
            // Let's stick to visual updates for now to avoid data loss.
        }

        if (Object.keys(updateData).length === 0) {
            return JSON.stringify({ success: false, error: "Nenhuma altera√ß√£o fornecida." });
        }

        const { error } = await supabase.from('collections').update(updateData).eq('id', coll.id);
        if (error) {
            return JSON.stringify({ success: false, error: error.message });
        }
        return JSON.stringify({ success: true, message: `Pasta "${args.name}" atualizada.` });

    } else if (args.action === 'delete') {
        const { data: collToDelete } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.name).maybeSingle();
        if (!collToDelete) return JSON.stringify({ success: false, error: `Pasta "${args.name}" n√£o encontrada.` });

        const { count } = await supabase.from('collection_items').select('*', { count: 'exact', head: true }).eq('collection_id', collToDelete.id);

        if (count && count > 0 && !args.force) {
            return JSON.stringify({ success: false, error: `Pasta n√£o vazia (${count} itens). Use force: true para deletar.` });
        }

        const { error } = await supabase.from('collections').delete().eq('user_id', userId).eq('name', args.name);
        if (error) return JSON.stringify({ success: false, error: error.message });

        return JSON.stringify({ success: true, message: `Pasta "${args.name}" apagada.` });
    }
    return JSON.stringify({ success: false, error: "A√ß√£o desconhecida." });
}

async function handleGlobalSearch(supabase: any, userId: string, args: any) {
    const query = args.query;
    const limit = args.limit || 10;
    const results: string[] = [];

    // 1. Search Collection Items (Content & Metadata)
    const { data: items } = await supabase
        .from('collection_items')
        .select('content, metadata, collections(name)')
        .eq('user_id', userId)
        .or(`content.ilike.%${query}%`)
        .limit(limit);

    if (items && items.length > 0) {
        items.forEach((i: any) => {
            results.push(`[ITEM] Pasta: ${i.collections?.name || '?'} | ${i.content} | ${JSON.stringify(i.metadata)}`);
        });
    }

    // 2. Search Reminders
    const { data: reminders } = await supabase
        .from('reminders')
        .select('title, due_at, is_completed')
        .eq('user_id', userId)
        .ilike('title', `%${query}%`)
        .limit(limit);

    if (reminders && reminders.length > 0) {
        reminders.forEach((r: any) => {
            results.push(`[LEMBRETE] ${r.title} (${new Date(r.due_at).toLocaleString('pt-BR')}) [${r.is_completed ? 'Feito' : 'Pendente'}]`);
        });
    }

    if (results.length === 0) {
        return `N√£o encontrei nada sobre "${query}" em nenhuma pasta ou lembrete.`;
    } else {
        return `Resultados para "${query}":\n${results.join('\n')}`;
    }
}
async function handleMigrateLegacy(supabase: any, userId: string, args: any) {
    const limit = args.limit || 5;

    // 1. Fetch candidates (generic or missing entity_type)
    const { data: allCollections } = await supabase.from('collections').select('id, name, metadata, collection_items(content)').eq('user_id', userId);

    const zombies = allCollections.filter((c: any) => !c.metadata?.entity_type || c.metadata.entity_type === 'generic');

    if (zombies.length === 0) return JSON.stringify({ success: true, message: "Nenhuma cole√ß√£o legada encontrada." });

    const toProcess = zombies.slice(0, limit);
    const report = [];

    for (const col of toProcess) {
        const itemsSample = col.collection_items?.slice(0, 3).map((i: any) => i.content).join(', ') || "Vazia";

        report.push({
            id: col.id,
            name: col.name,
            current_type: col.metadata?.entity_type || 'NULL',
            suggested_action: "REQUIRES_CLASSIFICATION",
            items_context: itemsSample
        });
    }

    return JSON.stringify({
        success: true,
        message: `Encontradas ${zombies.length} cole√ß√µes legadas. Mostrando ${toProcess.length}.`,
        candidates: report,
        instruction: "Para corrigir, use 'manage_collections' com action='update' e defina o entity_type correto para cada uma."
    });
}
