                        } else {
                            processedText = 'N√£o foi poss√≠vel transcrever o √°udio.';
                        }
                    }

                } catch (error: any) {
                    console.error('‚ùå Error processing audio:', error);
                    await supabase.from('debug_logs').insert({
                        function_name: 'process-message',
                        level: 'error',
                        message: 'Audio processing exception',
                        meta: { error: error.message, stack: error.stack }
                    });
                    processedText = 'Erro ao processar √°udio. Por favor, envie novamente.';
                }
            }
        }

        console.log('üìù FINAL TEXT SENT TO AI:', processedText);

        // --- AUDIO TRANSCRIPTION UPDATE (FIX VISIBILITY) ---
        // If we have a messageId and the text was transcribed (it was audio), update the DB
        if (messageId && processedText && mediaType === 'audio') {
            console.log(`üíæ Updating transcription for message ${messageId}...`);
            await supabase.from('messages').update({
                content: processedText
            }).eq('id', messageId);
        }

        // --- üïµÔ∏è MONITORING SYSTEM (NEW) ---
        // Check if this message triggers any active monitors
        if (processedText && !isOwner) { // Only check messages from OTHERS (not the owner)
            const { data: monitors } = await supabase
                .from('monitors')
                .select('*')
                .eq('user_id', userId)
                .eq('is_active', true);

            if (monitors && monitors.length > 0) {
                const matches = monitors.filter((m: any) => {
                    // Check keyword match (case insensitive)
                    const keywordMatch = processedText.toLowerCase().includes(m.keyword.toLowerCase());
                    // Check chat context match (if specified)
                    const chatMatch = !m.chat_name || (group_name && group_name.toLowerCase().includes(m.chat_name.toLowerCase()));
                    return keywordMatch && chatMatch;
                });

                if (matches.length > 0) {
                    console.log(`üîî MONITOR TRIGGERED: ${matches.length} matches found.`);
                    // We found a match! We need to notify the user.
                    // We inject a high-priority system message to force the AI to handle this.
                    systemPrompt += `\n\nüö® ALERTA DE MONITORAMENTO: A mensagem acima contem "${matches[0].keyword}" que voc√™ estava monitorando!
                    A√ß√£o Obrigat√≥ria: Avise o usu√°rio IMEDIATAMENTE.
                    Mensagem: "${processedText}"
                    Contexto: ${group_name || 'Chat Privado'}
                    Regra: ${matches[0].frequency} (Se for 'once', avise que vai parar de monitorar. Se for 'ask', pergunte se deve parar).`;
                }
            }
        }

        // --- üß† MEMORY LAYER: SAVE USER MESSAGE & RETRIEVE HISTORY ---

        // 1. Salvar mensagem do usu√°rio no hist√≥rico
        // REMOVIDO: A responsabilidade de salvar a mensagem do usu√°rio √© do CLIENTE (App ou Webhook).
        // Isso evita duplica√ß√£o.
        /*
        if (processedText) {
            await supabase.from('messages').insert({
                user_id: userId,
                role: 'user',
                content: processedText,
                media_url: mediaUrl || null,
                media_type: mediaType || null
            });
        }
        */

        // 2. Recuperar hist√≥rico recente (Curto Prazo)
        // Pegamos as √∫ltimas 10 mensagens para dar contexto
        const { data: historyData } = await supabase
            .from('messages')
            .select('role, content')
            .eq('user_id', userId)
            .order('created_at', { ascending: false })
            .limit(10);

        // Reverter para ordem cronol√≥gica (mais antigo -> mais novo)
        const history = historyData ? historyData.reverse() : [];

        // Filtrar mensagens de sistema ou erros se necess√°rio (opcional)
        // E remover a √∫ltima mensagem se ela for a que acabamos de inserir (para n√£o duplicar no prompt se o delay for curto)
        // Mas como inserimos agora, ela vai vir no select.
        // A l√≥gica padr√£o da OpenAI √©: System -> History -> User (New)
        // Se a mensagem nova j√° est√° no history, n√£o precisamos dar push de novo no final, OU removemos do history.
        // Vamos remover a √∫ltima do history se for igual ao processedText, para garantir a estrutura correta.

        const contextMessages = history.filter((msg: any) => msg.content !== processedText);

        console.log(`üß† Context loaded: ${contextMessages.length} previous messages.`);

        // --- BUILD MESSAGES ARRAY ---
        const messages: any[] = [
            { role: 'system', content: systemPrompt || DEFAULT_SYSTEM_PROMPT },
            ...contextMessages.map((msg: any) => ({
                role: msg.role,
                content: msg.content || (msg.media_url ? '[Media Message]' : '') // Fallback for null content
            }))
        ];

        if (mediaUrl && mediaType !== 'audio') {
            messages.push({
                role: 'system',
                content: `[User attached a file / media.URL: ${mediaUrl} (Type: ${mediaType})]`
            });
        }

        if (mediaUrl && mediaType === 'image') {
            messages.push({
                role: 'user',
                content: [
                    { type: 'text', text: processedText },
                    { type: 'image_url', image_url: { url: mediaUrl } }
                ]
            });
        } else {
            messages.push({ role: 'user', content: processedText });
        }

        // Multi-turn loop (ReAct pattern)
        let loopCount = 0;
        const MAX_LOOPS = 5;
        let finalResponse = "";

        while (loopCount < MAX_LOOPS) {
            loopCount++;

            // Call OpenAI with current history
            // --- MODEL SELECTION LOGIC ---
            // User requires GPT 5.1. We try to use it.
            // If it fails (because it might not exist yet publicly), we fallback to GPT-4o.
            let modelToUse = aiModel;

            // REMOVED: Forced mapping. We now trust the user and try the model.
            // if (aiModel === 'gpt-5.1-preview') { ... }

            console.log(`ü§ñ Final Model for Inference: ${modelToUse} (Requested: ${aiModel})`);

            let gptResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${openaiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: modelToUse,
                    messages: messages,
                    tools: tools,
                    tool_choice: 'auto',
                    temperature: 0.7, // Criatividade balanceada
                }),
            });

            // --- FALLBACK LOGIC ---
            if (!gptResponse.ok && modelToUse === 'gpt-5.1-preview') {
                console.warn('‚ö†Ô∏è GPT 5.1 failed (likely not available). Falling back to GPT-4o.');
                await supabase.from('debug_logs').insert({
                    function_name: 'process-message',
                    level: 'warning',
                    message: 'GPT 5.1 failed, falling back to GPT-4o',
                    meta: { status: gptResponse.status }
                });

                modelToUse = 'gpt-4o';
                gptResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${openaiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: modelToUse,
                        messages: messages,
                        tools: tools,
                        tool_choice: 'auto',
                        temperature: 0.7,
                    }),
                });
            }

            const gptData = await gptResponse.json();

            if (!gptData.choices?.[0]) {
                console.error('GPT Error:', gptData);
                throw new Error('Erro na comunica√ß√£o com a AI');
            }

            const message = gptData.choices[0].message;

            // Add assistant's message to history
            messages.push(message);

            // LOG THOUGHTS (Chain of Thought)
            if (message.content) {
                console.log('üí≠ THOUGHT:', message.content);
            }

            // If no tool calls, this is the final answer
            if (!message.tool_calls || message.tool_calls.length === 0) {
                finalResponse = message.content;
                break;
            }

            // Execute tool calls
            for (const toolCall of message.tool_calls) {
                const functionName = toolCall.function.name;
                const args = JSON.parse(toolCall.function.arguments);

                console.log(`üîß TOOL CALL: ${functionName}`);
                console.log(`üîß ARGS:`, JSON.stringify(args));

                let toolOutput = "";

                try {
                    // üõë SECURITY GUARD: AUTHORITY CHECK
                    if (!isOwner) {
                        console.warn(`üõë BLOCKED TOOL EXECUTION: ${functionName} called by non-owner (${senderName})`);
                        throw new Error(`‚õî A√ß√£o Bloqueada: Apenas o dono (${userSettings?.preferred_name || 'Vitor'}) pode executar comandos.`);
                    }

                    // LOG TOOL EXECUTION
                    await supabase.from('debug_logs').insert({
                        function_name: 'process-message',
                        level: 'info',
                        message: `Executing tool: ${functionName}`,
                        meta: { args: args }
                    });

                    // --- MANAGE COLLECTIONS ---
                    if (functionName === 'manage_collections') {
                        toolOutput = await handleManageCollections(supabase, userId, args);
                    }

                    // --- MANAGE FINANCIALS (NEW) ---
                    else if (functionName === 'manage_financials') {
                        if (args.action === 'add') {
                            if (!args.amount) {
                                toolOutput = "Erro: 'amount' √© obrigat√≥rio para finan√ßas. Pergunte ao usu√°rio o valor.";
                            } else {
                                // 1. Find/Create Collection
                                let collId = null;
                                const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                                if (!coll) {
                                    const { data: newColl } = await supabase.from('collections').insert({ user_id: userId, name: args.collection_name, icon: 'üí∞' }).select().single();
                                    collId = newColl.id;
                                } else {
                                    collId = coll.id;
                                }

                                // 2. Insert Item
                                const { error } = await supabase.from('collection_items').insert({
                                    collection_id: collId,
                                    user_id: userId,
                                    type: 'expense',
                                    content: args.description || 'Gasto sem descri√ß√£o',
                                    metadata: {
                                        amount: args.amount,
                                        category: args.category || 'Geral',
                                        section: args.category || 'Geral', // Use category as section for grouping
                                        date: args.date || new Date().toISOString()
                                    }
                                });

                                if (error) toolOutput = `Erro ao salvar gasto: ${error.message}`;
                                else toolOutput = `Gasto de ${args.amount} salvo em "${args.collection_name}".`;
                            }
                        } else if (args.action === 'list') {
                            // Reuse query_data logic internally or simplified list
                            toolOutput = "Use query_data para listar finan√ßas com filtros.";
                        } else if (args.action === 'delete') {
                            // Find collection
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                toolOutput = `Erro: Pasta "${args.collection_name}" n√£o encontrada.`;
                            } else {
                                // Search for item to delete
                                let query = supabase.from('collection_items').select('id, content, metadata').eq('collection_id', coll.id).eq('type', 'expense');
                                if (args.description) query = query.ilike('content', `%${args.description}%`);
                                if (args.amount) query = query.eq('metadata->>amount', args.amount);

                                const { data: items } = await query.limit(5);

                                if (!items || items.length === 0) {
                                    toolOutput = "Erro: Item financeiro n√£o encontrado para exclus√£o.";
                                } else if (items.length > 1) {
                                    const options = items.map((i: any) => `- ${i.content} (R$ ${i.metadata.amount})`).join('\n');
                                    toolOutput = `M√∫ltiplos itens encontrados. Qual apagar?\n${options}`;
                                } else {
                                    await supabase.from('collection_items').delete().eq('id', items[0].id);
                                    toolOutput = "Gasto removido com sucesso.";
                                }
                            }
                        } else if (args.action === 'update') {
                            // Find collection
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                toolOutput = `Erro: Pasta "${args.collection_name}" n√£o encontrada.`;
                            } else {
                                // Search for item to update
                                let query = supabase.from('collection_items').select('id, content, metadata').eq('collection_id', coll.id).eq('type', 'expense');
                                if (args.description) query = query.ilike('content', `%${args.description}%`);
                                // If searching by old amount to find the item
                                if (args.search_amount) query = query.eq('metadata->>amount', args.search_amount);

                                const { data: items } = await query.limit(5);

                                if (!items || items.length === 0) {
                                    toolOutput = "Erro: Item financeiro n√£o encontrado para atualiza√ß√£o.";
                                } else if (items.length > 1) {
                                    const options = items.map((i: any) => `- ${i.content} (R$ ${i.metadata.amount})`).join('\n');
                                    toolOutput = `M√∫ltiplos itens encontrados. Qual atualizar?\n${options}`;
                                } else {
                                    const targetItem = items[0];
                                    const newMetadata = { ...targetItem.metadata };
                                    if (args.amount) newMetadata.amount = args.amount;
                                    if (args.category) {
                                        newMetadata.category = args.category;
                                        newMetadata.section = args.category;
                                    }
                                    if (args.date) newMetadata.date = args.date;

                                    await supabase.from('collection_items').update({
                                        content: args.new_description || targetItem.content,
                                        metadata: newMetadata
                                    }).eq('id', targetItem.id);
                                    toolOutput = "Gasto atualizado com sucesso.";
                                }
                            }
                        }
                    }

                    // --- MANAGE CREDENTIALS (NEW) ---
                    else if (functionName === 'manage_credentials') {
                        if (args.action === 'add') {
                            // 1. Find/Create Collection
                            let collId = null;
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                const { data: newColl } = await supabase.from('collections').insert({ user_id: userId, name: args.collection_name, icon: 'üîí' }).select().single();
                                collId = newColl.id;
                            } else {
                                collId = coll.id;
                            }

                            // 2. Insert Item
                            const { error } = await supabase.from('collection_items').insert({
                                collection_id: collId,
                                user_id: userId,
                                type: 'credential',
                                content: args.service_name || 'Credencial',
                                metadata: {
                                    username: args.username,
                                    password: args.password,
                                    url: args.url,
                                    notes: args.notes,
                                    type: 'credential' // Redundant but safe
                                }
                            });

                            if (error) toolOutput = `Erro ao salvar credencial: ${error.message}`;
                            else toolOutput = `Credencial para "${args.service_name}" salva com seguran√ßa.`;
                        } else if (args.action === 'delete') {
                            // Find collection
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                toolOutput = `Erro: Pasta "${args.collection_name}" n√£o encontrada.`;
                            } else {
                                // Search for item to delete
                                let query = supabase.from('collection_items').select('id, content, metadata').eq('collection_id', coll.id).eq('type', 'credential');
                                if (args.service_name) query = query.ilike('content', `%${args.service_name}%`);
                                if (args.username) query = query.eq('metadata->>username', args.username);

                                const { data: items } = await query.limit(5);

                                if (!items || items.length === 0) {
                                    toolOutput = "Erro: Credencial n√£o encontrada para exclus√£o.";
                                } else if (items.length > 1) {
                                    const options = items.map((i: any) => `- ${i.content} (User: ${i.metadata.username})`).join('\n');
                                    toolOutput = `M√∫ltiplas credenciais encontradas. Qual apagar?\n${options}`;
                                } else {
                                    await supabase.from('collection_items').delete().eq('id', items[0].id);
                                    toolOutput = "Credencial removida com sucesso.";
                                }
                            }
                        } else if (args.action === 'update') {
                            // Find collection
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                toolOutput = `Erro: Pasta "${args.collection_name}" n√£o encontrada.`;
                            } else {
                                // Search for item to update
                                let query = supabase.from('collection_items').select('id, content, metadata').eq('collection_id', coll.id).eq('type', 'credential');
                                if (args.service_name) query = query.ilike('content', `%${args.service_name}%`);
                                if (args.username) query = query.eq('metadata->>username', args.username);

                                const { data: items } = await query.limit(5);

                                if (!items || items.length === 0) {
                                    toolOutput = "Erro: Credencial n√£o encontrada para atualiza√ß√£o.";
                                } else if (items.length > 1) {
                                    const options = items.map((i: any) => `- ${i.content} (User: ${i.metadata.username})`).join('\n');
                                    toolOutput = `M√∫ltiplas credenciais encontradas. Qual atualizar?\n${options}`;
                                } else {
                                    const targetItem = items[0];
                                    const newMetadata = { ...targetItem.metadata };
                                    if (args.new_username) newMetadata.username = args.new_username;
                                    if (args.new_password) newMetadata.password = args.new_password;
                                    if (args.url) newMetadata.url = args.url;
                                    if (args.notes) newMetadata.notes = args.notes;

                                    await supabase.from('collection_items').update({
                                        content: args.new_service_name || targetItem.content,
                                        metadata: newMetadata
                                    }).eq('id', targetItem.id);
                                    toolOutput = "Credencial atualizada com sucesso.";
                                }
                            }
                        }
                    }

                    // --- MANAGE INVENTORY (NEW) ---
                    else if (functionName === 'manage_inventory') {
                        if (args.action === 'add') {
                            // 1. Find/Create Collection
                            let collId = null;
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                const { data: newColl } = await supabase.from('collections').insert({ user_id: userId, name: args.collection_name, icon: 'üìã' }).select().single();
                                collId = newColl.id;
                            } else {
                                collId = coll.id;
                            }

                            // 2. Batch Insert
                            if (args.items && args.items.length > 0) {
                                const itemsToInsert = args.items.map((item: any) => ({
                                    collection_id: collId,
                                    user_id: userId,
                                    type: 'list_item', // Default for inventory
                                    content: item.content,
                                    metadata: {
                                        quantity: item.quantity,
                                        category: item.category,
                                        section: item.category || 'Geral',
                                        checked: item.checked || false,
                                        notes: item.notes,
                                        type: 'list_item'
                                    }
                                }));

                                const { error } = await supabase.from('collection_items').insert(itemsToInsert);
                                if (error) toolOutput = `Erro ao salvar lista: ${error.message}`;
                                else toolOutput = `${args.items.length} itens adicionados √† lista "${args.collection_name}".`;
                            } else {
                                toolOutput = "Nenhum item fornecido para a lista.";
                            }
                        } else if (args.action === 'delete') {
                            // Find collection
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                toolOutput = `Erro: Pasta "${args.collection_name}" n√£o encontrada.`;
                            } else {
                                // Search for item to delete
                                let query = supabase.from('collection_items').select('id, content, metadata').eq('collection_id', coll.id).eq('type', 'list_item');
                                if (args.content) query = query.ilike('content', `%${args.content}%`);

                                const { data: items } = await query.limit(5);

                                if (!items || items.length === 0) {
                                    toolOutput = "Erro: Item da lista n√£o encontrado para exclus√£o.";
                                } else if (items.length > 1) {
                                    const options = items.map((i: any) => `- ${i.content}`).join('\n');
                                    toolOutput = `M√∫ltiplos itens parecidos. Qual apagar?\n${options}`;
                                } else {
                                    await supabase.from('collection_items').delete().eq('id', items[0].id);
                                    toolOutput = "Item removido da lista com sucesso.";
                                }
                            }
                        } else if (args.action === 'update') {
                            // Find collection
                            const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();
                            if (!coll) {
                                toolOutput = `Erro: Pasta "${args.collection_name}" n√£o encontrada.`;
                            } else {
                                // Search for item to update
                                let query = supabase.from('collection_items').select('id, content, metadata').eq('collection_id', coll.id).eq('type', 'list_item');
                                if (args.content) query = query.ilike('content', `%${args.content}%`);

                                const { data: items } = await query.limit(5);

                                if (!items || items.length === 0) {
