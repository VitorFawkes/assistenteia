                            toolOutput = results.length > 0 ? results.join('\n\n') : "Nenhum resultado encontrado.";
                        }
                    }

                    // --- MANAGE USERS (ADMIN ONLY) ---
                    else if (functionName === 'manage_users') {
                        if (!userSettings?.is_admin) {
                            throw new Error("‚õî ACESSO NEGADO: Apenas administradores podem usar esta ferramenta.");
                        }

                        console.log('üõ°Ô∏è ADMIN ACTION:', args);

                        if (args.action === 'list') {
                            const { data: users, error } = await supabase
                                .from('user_settings')
                                .select('user_id, preferred_name, ai_model, is_admin');

                            if (error) throw error;

                            const userList = users.map((u: any) =>
                                `- ${u.preferred_name || 'Sem Nome'} (ID: ${u.user_id}) [Model: ${u.ai_model}] ${u.is_admin ? 'üõ°Ô∏è ADMIN' : ''}`
                            ).join('\n');

                            toolOutput = `üë• Lista de Usu√°rios:\n${userList}`;
                        }
                        else if (args.action === 'update_model') {
                            if (!args.target_user_id || !args.model) throw new Error("target_user_id e model s√£o obrigat√≥rios.");

                            const { error } = await supabase
                                .from('user_settings')
                                .update({ ai_model: args.model })
                                .eq('user_id', args.target_user_id);

                            if (error) throw error;
                            toolOutput = `‚úÖ Modelo do usu√°rio ${args.target_user_id} atualizado para ${args.model}.`;
                        }
                        else if (args.action === 'delete') {
                            if (!args.target_user_id) throw new Error("target_user_id √© obrigat√≥rio.");

                            // Delete from auth.users? No, we can't do that easily from here without service role key with special perms.
                            // But we can delete from user_settings and data tables.
                            // Actually, let's just delete user_settings for now as a soft delete/reset.
                            // Or better: just warn that we can't fully delete auth user.

                            const { error } = await supabase
                                .from('user_settings')
                                .delete()
                                .eq('user_id', args.target_user_id);

                            if (error) throw error;
                            toolOutput = `‚ö†Ô∏è Configura√ß√µes do usu√°rio ${args.target_user_id} apagadas. (A conta Auth ainda existe).`;
                        }
                    }

                    // --- MANAGE CALENDAR ---
                    else if (functionName === 'manage_calendar') {
                        console.log('üìÖ Managing Calendar:', args);
                        const targetProvider = args.provider || 'all';
                        const providersToFetch = targetProvider === 'all' ? ['google', 'microsoft'] : [targetProvider];

                        const { data: integrations } = await supabase
                            .from('user_integrations')
                            .select('*')
                            .eq('user_id', userId)
                            .in('provider', providersToFetch);

                        if (!integrations || integrations.length === 0) {
                            toolOutput = "Nenhuma conta de calend√°rio conectada. Por favor, conecte Google ou Outlook nas configura√ß√µes.";
                        } else {
                            const results = [];

                            for (const integration of integrations) {
                                try {
                                    let accessToken = integration.access_token;
                                    const expiresAt = new Date(integration.expires_at);
                                    const now = new Date();
                                    const isGoogle = integration.provider === 'google';
                                    const isMicrosoft = integration.provider === 'microsoft';

                                    // --- REFRESH TOKEN LOGIC ---
                                    if (expiresAt.getTime() - now.getTime() < 5 * 60 * 1000) {
                                        console.log(`üîÑ Refreshing ${integration.provider} Token...`);
                                        let refreshUrl = '';
                                        let bodyParams: any = {};

                                        if (isGoogle) {
                                            refreshUrl = 'https://oauth2.googleapis.com/token';
                                            bodyParams = {
                                                client_id: Deno.env.get('GOOGLE_CLIENT_ID')!,
                                                client_secret: Deno.env.get('GOOGLE_CLIENT_SECRET')!,
                                                refresh_token: integration.refresh_token,
                                                grant_type: 'refresh_token',
                                            };
                                        } else if (isMicrosoft) {
                                            refreshUrl = 'https://login.microsoftonline.com/common/oauth2/v2.0/token';
                                            bodyParams = {
                                                client_id: Deno.env.get('MICROSOFT_CLIENT_ID')!,
                                                client_secret: Deno.env.get('MICROSOFT_CLIENT_SECRET')!,
                                                refresh_token: integration.refresh_token,
                                                grant_type: 'refresh_token',
                                            };
                                        }

                                        const refreshResponse = await fetch(refreshUrl, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                            body: new URLSearchParams(bodyParams),
                                        });

                                        const refreshData = await refreshResponse.json();
                                        if (refreshData.error) throw new Error(refreshData.error_description || refreshData.error);

                                        accessToken = refreshData.access_token;
                                        const newExpiresAt = new Date(Date.now() + refreshData.expires_in * 1000).toISOString();

                                        await supabase.from('user_integrations').update({
                                            access_token: accessToken,
                                            expires_at: newExpiresAt,
                                            updated_at: new Date().toISOString()
                                        }).eq('id', integration.id);
                                    }

                                    const headers = {
                                        'Authorization': `Bearer ${accessToken}`,
                                        'Content-Type': 'application/json'
                                    };

                                    // --- EXECUTE ACTIONS ---
                                    if (args.action === 'list_events') {
                                        const timeMin = args.start_date || new Date().toISOString();
                                        const timeMax = args.end_date || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(); // Default 7 days

                                        if (isGoogle) {
                                            const url = `https://www.googleapis.com/calendar/v3/calendars/primary/events?timeMin=${timeMin}&timeMax=${timeMax}&singleEvents=true&orderBy=startTime`;
                                            const res = await fetch(url, { headers });
                                            const data = await res.json();
                                            if (data.items) {
                                                results.push(...data.items.map((e: any) => {
                                                    const start = e.start.dateTime ? new Date(e.start.dateTime).toLocaleString('pt-BR') : `${e.start.date} (Dia todo)`;
                                                    return `[GOOGLE] ${start} - ${e.summary} (ID: ${e.id})`;
                                                }));
                                            }
                                        } else if (isMicrosoft) {
                                            const url = `https://graph.microsoft.com/v1.0/me/calendarView?startDateTime=${timeMin}&endDateTime=${timeMax}&$top=20&$select=id,subject,start,end,isAllDay`;
                                            const res = await fetch(url, { headers });
                                            const data = await res.json();
                                            if (data.value) {
                                                results.push(...data.value.map((e: any) => {
                                                    const start = e.isAllDay ? `${e.start.dateTime.split('T')[0]} (Dia todo)` : new Date(e.start.dateTime).toLocaleString('pt-BR');
                                                    return `[OUTLOOK] ${start} - ${e.subject} (ID: ${e.id})`;
                                                }));
                                            }
                                        }
                                    }
                                    else if (args.action === 'create_event') {
                                        // Create in the first available provider if not specified, or all?
                                        // Usually user wants one calendar. Let's default to Google if available, else Microsoft.
                                        // Or if provider specified.
                                        // If 'all' (default), let's pick Google first.

                                        // Logic: If we are iterating and provider is 'all', we might duplicate.
                                        // Let's control this: Only create ONCE.
                                        // But we are inside a loop.
                                        // Let's assume if provider is NOT specified, we prefer Google.
                                        // If we are in Microsoft loop and Google was already processed (and successful?), skip?
                                        // Simpler: Just try to create in the current integration.

                                        const startTime = args.start_time;
                                        let endTime = args.end_time;
                                        if (!endTime && startTime) {
                                            const d = new Date(startTime);
                                            d.setHours(d.getHours() + 1);
                                            endTime = d.toISOString();
                                        }

                                        if (isGoogle) {
                                            const event = {
                                                summary: args.title,
                                                description: args.description,
                                                start: args.all_day ? { date: startTime.split('T')[0] } : { dateTime: startTime },
                                                end: args.all_day ? { date: endTime.split('T')[0] } : { dateTime: endTime },
                                                location: args.location
                                            };
                                            const res = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {
                                                method: 'POST', headers, body: JSON.stringify(event)
                                            });
                                            const data = await res.json();
                                            if (data.id) results.push(`[GOOGLE] Evento criado: "${args.title}" em ${new Date(startTime).toLocaleString('pt-BR')}`);
                                            else results.push(`[GOOGLE] Erro ao criar: ${JSON.stringify(data)}`);
                                        }
                                        else if (isMicrosoft) {
                                            const event = {
                                                subject: args.title,
                                                body: { contentType: 'Text', content: args.description || '' },
                                                start: { dateTime: startTime, timeZone: 'America/Sao_Paulo' },
                                                end: { dateTime: endTime, timeZone: 'America/Sao_Paulo' },
                                                location: { displayName: args.location },
                                                isAllDay: args.all_day
                                            };
                                            const res = await fetch('https://graph.microsoft.com/v1.0/me/events', {
                                                method: 'POST', headers, body: JSON.stringify(event)
                                            });
                                            const data = await res.json();
                                            if (data.id) results.push(`[OUTLOOK] Evento criado: "${args.title}" em ${new Date(startTime).toLocaleString('pt-BR')}`);
                                            else results.push(`[OUTLOOK] Erro ao criar: ${JSON.stringify(data)}`);
                                        }
                                    }
                                    else if (args.action === 'delete_event') {
                                        let eventIdToDelete = args.event_id;

                                        // SMART LOGIC: If no ID, try to find by title
                                        if (!eventIdToDelete && args.title) {
                                            if (isGoogle) {
                                                const searchUrl = `https://www.googleapis.com/calendar/v3/calendars/primary/events?q=${encodeURIComponent(args.title)}&timeMin=${new Date().toISOString()}&maxResults=5`;
                                                const searchRes = await fetch(searchUrl, { headers });
                                                const searchData = await searchRes.json();
                                                const candidates = searchData.items || [];

                                                if (candidates.length === 0) {
                                                    results.push(`[GOOGLE] N√£o encontrei nenhum evento futuro com o t√≠tulo "${args.title}".`);
                                                } else if (candidates.length > 1) {
                                                    const options = candidates.map((e: any) => `- ${e.summary} (${new Date(e.start.dateTime || e.start.date).toLocaleString('pt-BR')}) [ID: ${e.id}]`).join('\n');
                                                    results.push(`[GOOGLE] Encontrei m√∫ltiplos eventos. Qual deles apagar?\n${options}`);
                                                } else {
                                                    eventIdToDelete = candidates[0].id;
                                                }
                                            } else if (isMicrosoft) {
                                                const searchUrl = `https://graph.microsoft.com/v1.0/me/events?$filter=contains(subject,'${args.title}') and start/dateTime ge '${new Date().toISOString()}'&$top=5`;
                                                const searchRes = await fetch(searchUrl, { headers });
                                                const searchData = await searchRes.json();
                                                const candidates = searchData.value || [];

                                                if (candidates.length === 0) {
                                                    results.push(`[OUTLOOK] N√£o encontrei nenhum evento futuro com o t√≠tulo "${args.title}".`);
                                                } else if (candidates.length > 1) {
                                                    const options = candidates.map((e: any) => `- ${e.subject} (${new Date(e.start.dateTime).toLocaleString('pt-BR')}) [ID: ${e.id}]`).join('\n');
                                                    results.push(`[OUTLOOK] Encontrei m√∫ltiplos eventos. Qual deles apagar?\n${options}`);
                                                } else {
                                                    eventIdToDelete = candidates[0].id;
                                                }
                                            }
                                        }

                                        if (!eventIdToDelete && !args.title) {
                                            results.push("Erro: ID do evento ou T√≠tulo necess√°rio para deletar.");
                                        } else if (eventIdToDelete) {
                                            if (isGoogle) {
                                                const res = await fetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventIdToDelete}`, { method: 'DELETE', headers });
                                                if (res.ok) results.push(`[GOOGLE] Evento apagado com sucesso.`);
                                                else results.push(`[GOOGLE] Erro ao apagar: ${(await res.json()).error?.message}`);
                                            } else if (isMicrosoft) {
                                                const res = await fetch(`https://graph.microsoft.com/v1.0/me/events/${eventIdToDelete}`, { method: 'DELETE', headers });
                                                if (res.ok) results.push(`[OUTLOOK] Evento apagado com sucesso.`);
                                                else results.push(`[OUTLOOK] Erro ao apagar: ${await res.text()}`);
                                            }
                                        }
                                    }

                                } catch (err: any) {
                                    console.error(`Error processing Calendar ${integration.provider}:`, err);
                                    results.push(`[${integration.provider.toUpperCase()}] Erro: ${err.message}`);
                                }
                            }

                            toolOutput = results.length > 0 ? results.join('\n') : "Nenhum evento encontrado ou a√ß√£o realizada.";
                        }
                    }

                    // --- SEARCH CONTACTS ---
                    else if (functionName === 'search_contacts') {
                        const { data: contacts } = await supabase
                            .from('messages')
                            .select('sender_name, sender_number, created_at')
                            .eq('user_id', userId) // üîí SECURITY: Isolate by user
                            .or(`sender_name.ilike.%${args.query}%,sender_number.ilike.%${args.query}%`) // Search Name OR Number
                            .order('created_at', { ascending: false })
                            .limit(50); // Increased limit to find valid numbers among LIDs

                        if (!contacts || contacts.length === 0) {
                            toolOutput = `Nenhum contato encontrado com o nome "${args.query}". Tente buscar por parte do nome.`;
                        } else {
                            // Group by number to avoid duplicates
                            const uniqueContacts = new Map();
                            contacts.forEach((c: any) => {
                                if (!uniqueContacts.has(c.sender_number)) {
                                    uniqueContacts.set(c.sender_number, {
                                        name: c.sender_name,
                                        number: c.sender_number,
                                        last_seen: c.created_at
                                    });
                                }
                            });

                            // Sort: Prioritize numbers starting with 55 and length 12-13 (BR Mobile)
                            const sortedContacts = Array.from(uniqueContacts.values()).sort((a: any, b: any) => {
                                const isAValid = a.number.startsWith('55') && a.number.length >= 12 && a.number.length <= 13;
                                const isBValid = b.number.startsWith('55') && b.number.length >= 12 && b.number.length <= 13;
                                if (isAValid && !isBValid) return -1;
                                if (!isAValid && isBValid) return 1;
                                return new Date(b.last_seen).getTime() - new Date(a.last_seen).getTime(); // Fallback to recency
                            });

                            const list = sortedContacts.map((c: any) => {
                                const isValid = c.number.startsWith('55') && c.number.length >= 12 && c.number.length <= 13;
                                const tag = isValid ? '[üì± CELULAR]' : '[‚ùì OUTRO/ID]';
                                return `- ${c.name} (${c.number}) ${tag} [Visto em: ${new Date(c.last_seen).toLocaleDateString('pt-BR')}]`;
                            }).join('\n');

                            toolOutput = `Contatos encontrados para "${args.query}":\n${list}\n\nPREFIRA N√öMEROS MARCADOS COMO [üì± CELULAR]. Evite [‚ùì OUTRO/ID] se poss√≠vel.`;
                        }
                    }

                    // --- QUERY DATA ---
                    else if (functionName === 'query_data') {
                        const { data: coll } = await supabase.from('collections').select('id').eq('user_id', userId).eq('name', args.collection_name).maybeSingle();

                        if (!coll) {
                            toolOutput = `Pasta "${args.collection_name}" n√£o encontrada.`;
                        } else {
                            if (args.start_date) {
                                // Precisamos filtrar por metadata->>date.
                            }

                            // NOVA L√ìGICA DE FILTRO DE DATA (H√≠brida)
                            // Se args.start_date/end_date forem passados, filtramos no banco pelo created_at (performance)
                            // E TAMB√âM filtramos por metadata->>date se existir.

                            // Como n√£o d√° pra fazer OR complexo f√°cil aqui, vamos fazer o seguinte:
                            // Buscar tudo (com limite razo√°vel) e filtrar no c√≥digo.
                            const { data: allItems } = await supabase
                                .from('collection_items')
                                .select('*')
                                .eq('collection_id', coll.id)
                                .order('created_at', { ascending: false })
                                .limit(500); // Limite de seguran√ßa

                            let items = allItems || [];

                            if (args.start_date) {
                                items = items.filter(i => {
                                    const itemDate = i.metadata?.date || i.created_at;
                                    return itemDate >= args.start_date;
                                });
                            }
                            if (args.end_date) {
                                items = items.filter(i => {
                                    const itemDate = i.metadata?.date || i.created_at;
                                    return itemDate <= args.end_date;
                                });
                            }

                            if (args.filter_key && args.filter_value) {
                                items = items.filter(i => i.metadata?.[args.filter_key] === args.filter_value);
                            }

                            // A query original foi substitu√≠da pela l√≥gica in-memory acima.
                            // const { data: items } = await query;

                            if (!items || items.length === 0) {
                                toolOutput = `Nenhum dado encontrado com esses filtros em "${args.collection_name}".`;
                            } else {
                                if (args.operation === 'sum' && args.field) {
                                    const total = items.reduce((acc: number, item: any) => acc + (Number(item.metadata?.[args.field]) || 0), 0);

                                    // Generate list for context (fallback for unstructured data)
                                    const list = items.map((i: any) => `- ${i.content || ''} (Meta: ${JSON.stringify(i.metadata || {})})`).join('\n');

                                    toolOutput = `Total (via metadata '${args.field}'): ${total}.\n\nItens considerados:\n${list}\n\n(Se o total for 0, verifique os itens acima para somar manualmente)`;
                                } else if (args.operation === 'count') {
                                    toolOutput = `Total de itens: ${items.length} `;
                                } else if (args.operation === 'average' && args.field) {
                                    const total = items.reduce((acc: number, item: any) => acc + (Number(item.metadata?.[args.field]) || 0), 0);
                                    const list = items.map((i: any) => `- ${i.content || ''} (Meta: ${JSON.stringify(i.metadata || {})})`).join('\n');
                                    toolOutput = `M√©dia (via metadata '${args.field}'): ${(total / items.length).toFixed(2)}.\n\nItens considerados:\n${list}`;
                                } else {
                                    // List
                                    const list = items.map((i: any) => {
                                        const meta = i.metadata ? JSON.stringify(i.metadata) : '';
                                        return `- ${i.content || ''} ${meta} `;
                                    }).join('\n');
                                    toolOutput = `Resultado: \n${list} `;
                                }
                            }
                        }
                    }


                    // --- GLOBAL SEARCH (NEW) ---
                    else if (functionName === 'global_search') {
                        toolOutput = await handleGlobalSearch(supabase, userId, args);
                    }

                    // --- MANAGE REMINDERS ---
                    else if (functionName === 'manage_reminders') {
                        if (args.action === 'create') {
                            const finalDueAt = calculateDueAt(args, brasiliaTime, overrideDueAt);

                            // VALIDA√á√ÉO FINAL
                            if (finalDueAt) {
                                const checkDate = new Date(finalDueAt);
                                const nowCheck = new Date();
                                const diffMinutes = (checkDate.getTime() - nowCheck.getTime()) / (1000 * 60);

                                console.log(`üîç DATE CHECK: Due = ${finalDueAt}, Diff = ${diffMinutes.toFixed(1)} min`);

                                if (diffMinutes < -5) {
                                    toolOutput = `ERRO: A data calculada(${finalDueAt}) est√° no passado.Por favor, seja mais espec√≠fico(ex: "amanh√£ √†s 10h").`;
                                    console.error('‚ùå REJECTED: Date in past');
                                } else {
                                    // SUCESSO - Inserir no banco
                                    const reminderData: any = {
                                        user_id: userId,
                                        title: args.title,
                                        due_at: finalDueAt,
                                        recurrence_type: args.recurrence_type || 'once',
                                        is_completed: false
                                    };

                                    if (args.recurrence_type && args.recurrence_type !== 'once') {
                                        if (args.recurrence_type === 'custom') {
                                            reminderData.recurrence_interval = args.recurrence_interval;
                                            reminderData.recurrence_unit = args.recurrence_unit;
                                        }
                                        if (args.recurrence_type === 'weekly' && args.weekdays) {
                                            reminderData.weekdays = args.weekdays;
                                        }
                                        if (args.recurrence_count) {
                                            reminderData.recurrence_count = args.recurrence_count;
                                        }
                                    }

                                    const { error } = await supabase.from('reminders').insert(reminderData);
                                    if (error) throw error;

                                    let confirmMsg = `Lembrete "${args.title}" agendado para ${finalDueAt} `;
                                    if (args.recurrence_type !== 'once') confirmMsg += ` (Recorrente: ${args.recurrence_type})`;
                                    toolOutput = confirmMsg;
                                }
                            } else {
                                toolOutput = "Erro: N√£o foi poss√≠vel calcular a data do lembrete. Tente novamente.";
                            }

                        } else if (args.action === 'list') {
                            const { data } = await supabase.from('reminders').select('*').eq('user_id', userId).eq('is_completed', false).order('due_at');
                            toolOutput = `Lembretes pendentes: ${data?.map((r: any) => `[ID: ${r.id}] ${r.title} (${r.due_at})`).join(', ') || "Nenhum"} `;
                        } else if (args.action === 'complete') {
                            if (args.id) {
                                await supabase.from('reminders').update({ is_completed: true }).eq('id', args.id).eq('user_id', userId);
                                toolOutput = `Lembrete marcado como conclu√≠do (ID: ${args.id}).`;
                            } else {
                                const search = args.search_title || args.title;
                                // 1. Try to find PENDING reminders first
                                const { data: pending } = await supabase
                                    .from('reminders')
                                    .select('id, title, due_at')
                                    .eq('user_id', userId)
                                    .eq('is_completed', false)
                                    .ilike('title', `%${search}%`);

                                if (pending && pending.length === 1) {
                                    // Perfect match
                                    await supabase.from('reminders').update({ is_completed: true }).eq('id', pending[0].id);
                                    toolOutput = `Lembrete "${pending[0].title}" marcado como conclu√≠do.`;
                                } else if (pending && pending.length > 1) {
                                    // Ambiguous
                                    const options = pending.map((r: any) => `- ${r.title} (${new Date(r.due_at).toLocaleString('pt-BR')}) [ID: ${r.id}]`).join('\n');
                                    toolOutput = `Encontrei m√∫ltiplos lembretes pendentes com esse nome. Qual deles voc√™ quer concluir?\n${options}\n\nPor favor, repita o comando usando o ID ou o nome mais espec√≠fico.`;
                                } else {
                                    // No pending found, check completed?
                                    const { data: completed } = await supabase
                                        .from('reminders')
                                        .select('id, title')
                                        .eq('user_id', userId)
                                        .eq('is_completed', true)
                                        .ilike('title', `%${search}%`)
                                        .limit(1);

                                    if (completed && completed.length > 0) {
                                        toolOutput = `O lembrete "${completed[0].title}" j√° estava conclu√≠do.`;
                                    } else {
                                        toolOutput = `N√£o encontrei nenhum lembrete chamado "${search}".`;
                                    }
                                }
                            }
                        } else if (args.action === 'update') {
                            // SMART LOGIC: Find reminder to update
                            let reminder = null;

                            if (args.id) {
                                const { data } = await supabase.from('reminders').select('*').eq('id', args.id).eq('user_id', userId).single();
                                reminder = data;
                            } else {
                                const search = args.title;
                                // Prioritize PENDING
                                const { data: pending } = await supabase.from('reminders').select('*').eq('user_id', userId).eq('is_completed', false).ilike('title', `%${search}%`).limit(5);

                                if (pending && pending.length === 1) {
                                    reminder = pending[0];
                                } else if (pending && pending.length > 1) {
                                    const options = pending.map((r: any) => `- ${r.title} (${new Date(r.due_at).toLocaleString('pt-BR')}) [ID: ${r.id}]`).join('\n');
